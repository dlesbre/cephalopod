// 2021-07-02
// This is what the language should look somewhat like once I make the frontend.
// Currently there's some awkwardness involving arity and tuples, sorry.


////////////////////////////////////////////////////////////////////////////////
// Types and things that would typically be in an included external file.
////////////////////////////////////////////////////////////////////////////////

// Declare some types. We skip "bit" as it is built-in.
type addr => "addr";  // address type that compiles to "addr"
type word;            // word type that will be left to FL to infer
alias wordpair = (word, word);  // a type alias (macro, basically)

type node => "node";
fields node = [laddr:addr, int:word];

// Here we declare that there are several independent aspects of global state,
// named "MEM_CONTENTS" and "MEM_LIFECYCLE". Why? So that the compiler can tell
// whether or not certain actions can be run concurrently, or if they would
// potentially interfere.
state MEM_CONTENTS;
state MEM_LIFECYCLE;

// The type for a action that reads from RAM. To prevent the compiler from
// parallelizing things it shouldn't, we indicate how this action type interacts
// with the global state--namely that it depends on the contents of RAM, but
// doesn't change anything.
actiontype MemRead = addr:addr -> dout:word reads [MEM_CONTENTS] writes [];

// The type for a action that writes to memory. Obviously this affects (writes)
// the state of RAM, but one could also argue that as memory is only partially
// overwritten (unless you have a 1-word memory) it also depends on (reads) the
// state of RAM. This distinction is subtle and thankfully doesn't matter to the
// compiler at present, since the writing precludes anything else involving
// MEM_CONTENTS from running at the same time anyway. We err on the side of
// caution, and mark it read here anyway.
actiontype MemWrite = (addr:addr, din:word) -> () reads [MEM_CONTENTS] writes [MEM_CONTENTS];

// And one for allocation. This one clearly both reads and writes MEM_LIFECYCLE,
// since the cell chosen for allocation depends on what's free at the moment.
actiontype MemAlloc = () -> addr:addr reads [MEM_LIFECYCLE] writes [MEM_LIFECYCLE];

// Addition with carry in and out. No interaction with state.
actiontype Adder = (a:word, b:word, c_in:bit) -> (sum:word, c_out:bit) reads [] writes [];


////////////////////////////////////////////////////////////////////////////////
// Stuff that would be in the main file you're compiling.
////////////////////////////////////////////////////////////////////////////////

// Action we actually use, and how they are provided. We can either let them be
// implemented externally (in which case the required IO signals will be
// created) or indicate a module to instantiate. A communication protocol is
// specified we well: "fourphase" for a four-phase handshake, or "combinational"
// for implementations where the result is available immediately and no
// handshake needs to be performed.
action mem_read:MemRead external via fourphase;
action mem_write:MemWrite external via fourphase;
action alloc:MemAlloc external via fourphase;
action adder1:Adder provided by "adder_with_carry" via combinational; // one!
action adder2:Adder provided by "adder_with_carry" via combinational; // two!

// The main subroutine of the module. The inputs and outputs from this determine
// the module's inputs and outputs (in addition to clk/reset and IO for external
// actions).
subroutine main : (x:addr, y:addr) -> z:addr
{
    var word a, b, c1, c2;

    // These will run sequentially as they interfere.
    a = do mem_read x;
    b = do mem_read y;

    // The following three lines should all run concurrently.
    z = do alloc;
    (c1,_) = do adder1 (a, b, 0);
    (c2,_) = do adder2 (b, a, 0);

    // Nested subroutine calls, inside a condition!?
    if(call checkEq (call hash c1, call hash c2))
    {
        // Whew! Addition is commutative!
        do mem_write (z, c1);
        return;
    }

    // Otherwise...
    z = "NULL_ADDR";
    for(a = 0; (call hash a) != (call hash b); (a,_) = do adder1 (a,1,0))
    {
        // (We have loops by the way.)
    }
    return;
}

// A subroutine that we can call.
subroutine checkEq : (foo:word, bar:word) -> equal:bit
{
    equal = (foo == bar);
    return;
}

// A subroutine that will be inlined wherever it is called.
subroutine inline hash : foo:word -> hashed:word
{
    hashed = ~foo;  // creative
    return;
}
