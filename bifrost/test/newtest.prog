name testmodule;

type addr => "addr";
type node => "node";
fields node = [laddr:addr, raddr:addr];
type mystery;

state MEM_CONTENTS, MEM_LIFECYCLE;

actiontype MemRead = a:addr -> d:node reading [MEM_CONTENTS] writing [];
actiontype MemWrite = a:addr -> d:node -> () reading [MEM_CONTENTS] writing [MEM_CONTENTS];
actiontype Adder = x:addr -> y:addr -> cin:bit -> (z:addr, cout:bit) reading [] writing [];

action mem_read:MemRead provided by external via fourphase;
action mem_write:MemWrite provided by external via fourphase;
action adder:Adder provided by "fancyadder" via combinational;

var bit gocrazy;

define magic x y = x + y;
define bananas x y = call silly x (call subtract x y) ;

subroutine main : x:addr -> y:addr -> z:addr
{
    var mystery count;
    
    gocrazy = 1;
    
    for(count = 0; count < 99; count = magic count 1)
    {
        bananas x y;
    }
    
    return;
}

subroutine silly : a0:addr -> a1:addr -> ()
{
    var node t0, t1;

    t0 = do mem_read a0;
    t1 = do mem_read a1;

    label foo:
    --%<--
    if(gocrazy)
    {
        do mem_write a0 t1;
        do mem_write a1 t0;
    }
    else
    {
        goto foo;
    }

    return;
}

subroutine inline subtract : x:addr -> y:addr -> z:addr
{
    z = (do adder x (~y) 1).0;

    return;
}
